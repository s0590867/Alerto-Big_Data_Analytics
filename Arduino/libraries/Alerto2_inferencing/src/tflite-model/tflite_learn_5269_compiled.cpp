/*
 * Copyright (c) 2025 EdgeImpulse Inc.
 *
 * Generated by Edge Impulse and licensed under the applicable Edge Impulse
 * Terms of Service. Community and Professional Terms of Service
 * (https://edgeimpulse.com/legal/terms-of-service) or Enterprise Terms of
 * Service (https://edgeimpulse.com/legal/enterprise-terms-of-service),
 * according to your product plan subscription (the “License”).
 *
 * This software, documentation and other associated files (collectively referred
 * to as the “Software”) is a single SDK variation generated by the Edge Impulse
 * platform and requires an active paid Edge Impulse subscription to use this
 * Software for any purpose.
 *
 * You may NOT use this Software unless you have an active Edge Impulse subscription
 * that meets the eligibility requirements for the applicable License, subject to
 * your full and continued compliance with the terms and conditions of the License,
 * including without limitation any usage restrictions under the applicable License.
 *
 * If you do not have an active Edge Impulse product plan subscription, or if use
 * of this Software exceeds the usage limitations of your Edge Impulse product plan
 * subscription, you are not permitted to use this Software and must immediately
 * delete and erase all copies of this Software within your control or possession.
 * Edge Impulse reserves all rights and remedies available to enforce its rights.
 *
 * Unless required by applicable law or agreed to in writing, the Software is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language governing
 * permissions, disclaimers and limitations under the License.
 */
// Generated on: 25.03.2025 14:34:50

#include <stdio.h>
#include <stdlib.h>
#include "edge-impulse-sdk/tensorflow/lite/c/builtin_op_data.h"
#include "edge-impulse-sdk/tensorflow/lite/c/common.h"
#include "edge-impulse-sdk/tensorflow/lite/micro/micro_mutable_op_resolver.h"
#include "edge-impulse-sdk/porting/ei_classifier_porting.h"

#if EI_CLASSIFIER_PRINT_STATE
#if defined(__cplusplus) && EI_C_LINKAGE == 1
extern "C" {
    extern void ei_printf(const char *format, ...);
}
#else
extern void ei_printf(const char *format, ...);
#endif
#endif

#define STRINGIZE(x) #x
#define STRINGIZE_VALUE_OF(x) STRINGIZE(x)

#if defined (__GNUC__)  /* GNU compiler */
#define ALIGN(X) __attribute__((aligned(X)))
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (_MSC_VER)
#define ALIGN(X) __declspec(align(X))
#elif defined (__TASKING__) /* TASKING Compiler */
#define ALIGN(X) __align(X)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__ARMCC_VERSION) /* Arm Compiler */
#define ALIGN(X) __ALIGNED(x)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__ICCARM__) /* IAR Compiler */
#define ALIGN(x) __attribute__((aligned(x)))
#define DEFINE_SECTION(x) __attribute__((section(x)))
#elif defined (__clang__) /* LLVM/Clang Compiler */
#define ALIGN(X) __ALIGNED(x)
#define DEFINE_SECTION(x) __attribute__((section(x)))
#endif

#if defined(EI_MODEL_SECTION) && (defined(__GNUC__) || defined(__clang__))
#define MODEL_SECTION(X) __attribute__((section(STRINGIZE_VALUE_OF(X))))
#else
#define MODEL_SECTION(X)
#endif

#ifndef EI_MAX_SCRATCH_BUFFER_COUNT
#ifndef CONFIG_IDF_TARGET_ESP32S3
#define EI_MAX_SCRATCH_BUFFER_COUNT 6
#else
#define EI_MAX_SCRATCH_BUFFER_COUNT 12
#endif // CONFIG_IDF_TARGET_ESP32S3
#endif // EI_MAX_SCRATCH_BUFFER_COUNT

#ifndef EI_MAX_OVERFLOW_BUFFER_COUNT
#define EI_MAX_OVERFLOW_BUFFER_COUNT 10
#endif // EI_MAX_OVERFLOW_BUFFER_COUNT

using namespace tflite;
using namespace tflite::ops;
using namespace tflite::ops::micro;

namespace {

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX) || defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
constexpr int kTensorArenaSize = 5232;
#else
constexpr int kTensorArenaSize = 4208;
#endif

#if defined(EI_CLASSIFIER_ALLOCATION_STATIC)
#if defined (EI_TENSOR_ARENA_LOCATION)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) DEFINE_SECTION(STRINGIZE_VALUE_OF(EI_TENSOR_ARENA_LOCATION));
#else
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#endif
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX)
#pragma Bss(".tensor_arena")
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16);
#pragma Bss()
#elif defined(EI_CLASSIFIER_ALLOCATION_STATIC_HIMAX_GNU)
uint8_t tensor_arena[kTensorArenaSize] ALIGN(16) __attribute__((section(".tensor_arena")));
#else
#define EI_CLASSIFIER_ALLOCATION_HEAP 1
uint8_t* tensor_arena = NULL;
#endif

static uint8_t* tensor_boundary;
static uint8_t* current_location;

template <int SZ, class T> struct TfArray {
  int sz; T elem[SZ];
};

enum used_operators_e {
  OP_RESHAPE, OP_CONV_2D, OP_MAX_POOL_2D, OP_FULLY_CONNECTED, OP_SOFTMAX,  OP_LAST
};

struct TensorInfo_t { // subset of TfLiteTensor used for initialization from constant memory
  TfLiteAllocationType allocation_type;
  TfLiteType type;
  void* data;
  TfLiteIntArray* dims;
  size_t bytes;
  TfLiteQuantization quantization;
};

typedef struct {
  TfLiteTensor tensor;
  int16_t index;
} TfLiteTensorWithIndex;

typedef struct {
  TfLiteEvalTensor tensor;
  int16_t index;
} TfLiteEvalTensorWithIndex;

TfLiteContext ctx{};
static const int MAX_TFL_TENSOR_COUNT = 4;
static TfLiteTensorWithIndex tflTensors[MAX_TFL_TENSOR_COUNT];
static const int MAX_TFL_EVAL_COUNT = 4;
static TfLiteEvalTensorWithIndex tflEvalTensors[MAX_TFL_EVAL_COUNT];
TfLiteRegistration registrations[OP_LAST];

namespace g0 {
const TfArray<2, int> tensor_dimension0 = { 2, { 1,1280 } };
const TfArray<1, float> quant0_scale = { 1, { 0.00390625, } };
const TfArray<1, int> quant0_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant0 = { (TfLiteFloatArray*)&quant0_scale, (TfLiteIntArray*)&quant0_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data1[4] = { 1, 1, 40, 32, };
const TfArray<1, int> tensor_dimension1 = { 1, { 4 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data2[4] = { 1, 40, 1, 8, };
const TfArray<1, int> tensor_dimension2 = { 1, { 4 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data3[4] = { 1, 1, 20, 8, };
const TfArray<1, int> tensor_dimension3 = { 1, { 4 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data4[4] = { 1, 20, 1, 16, };
const TfArray<1, int> tensor_dimension4 = { 1, { 4 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data5[4] = { 1, 1, 10, 16, };
const TfArray<1, int> tensor_dimension5 = { 1, { 4 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data6[4] = { 1, 10, 1, 32, };
const TfArray<1, int> tensor_dimension6 = { 1, { 4 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(8) int32_t tensor_data7[2] = { -1, 160, };
const TfArray<1, int> tensor_dimension7 = { 1, { 2 } };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data8[4] = { -35, -929, 579, -215, };
const TfArray<1, int> tensor_dimension8 = { 1, { 4 } };
const TfArray<1, float> quant8_scale = { 1, { 0.00055812217760831118, } };
const TfArray<1, int> quant8_zero = { 1, { 0 } };
const TfLiteAffineQuantization quant8 = { (TfLiteFloatArray*)&quant8_scale, (TfLiteIntArray*)&quant8_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data9[4*160] = { 
  -17, -69, -16, 82, -24, -9, -30, 50, -59, 59, 11, 76, -14, -18, 6, -60, -16, 29, -23, 14, -24, 19, -79, 28, 12, -16, -53, 4, -11, -72, -6, 38, 3, 15, 4, 54, -22, 1, -21, 18, -35, 32, -15, 59, -15, -29, 34, -46, 20, 32, -7, -22, 26, 18, -43, 19, 2, -5, -34, -39, -24, -19, -18, 25, -39, -36, 23, 45, -39, -46, -45, 38, 22, 9, -49, 40, -4, -47, 24, -88, 6, 4, -16, 2, -20, -4, -40, 23, 0, -36, -33, -14, -87, -31, -46, 50, -29, -70, -11, 40, -52, -45, -85, 3, -25, 22, -32, 27, -5, -28, 31, -44, -9, 42, -41, -22, -25, -7, -47, 3, 16, -27, -66, -2, -40, -59, -12, 18, -49, -54, 7, 63, -89, -25, -113, 38, -61, 36, -94, 70, 14, -9, 4, -80, -7, 21, -57, 19, 9, -1, -41, 28, -15, -82, -79, 14, -103, -127, -37, 30, 
  6, -42, -47, -41, 20, 4, 5, -45, -81, -59, 20, -34, 16, 19, -67, 30, -21, -43, 23, -7, 4, -31, 32, -46, -81, 58, 48, -23, 44, -19, -7, -72, 20, 1, -46, -44, 53, -5, 29, -19, -53, -59, 36, -79, 6, 7, -63, 24, -3, -63, 30, -18, 3, -65, 25, -101, -48, 40, 15, 0, 20, -31, -7, -51, 18, -10, 1, -21, 62, 14, 3, -15, -51, -71, 38, -58, 7, -9, -60, 28, -16, -67, 30, -8, -9, -31, 16, -47, -83, 34, 19, 14, 29, -48, -4, -72, -14, -5, 1, -53, 45, -5, 28, -33, -10, -60, 38, -24, -22, 14, -32, 29, -14, -42, -3, 21, -2, -70, 24, -55, -36, 31, 33, 30, 4, -50, -15, -72, 15, 12, -62, -70, 39, 42, 28, -45, -80, -34, 56, -40, -13, 3, -72, 53, -11, -59, 13, -11, -26, -39, 51, -98, -69, 50, 14, -4, 15, -21, -12, -87, 
  -3, -67, 34, -47, -50, 30, 0, -97, -7, -45, 0, -16, 13, 32, 0, -1, 18, 8, 17, -10, -6, 19, -3, -3, 25, -13, -41, -9, 21, -54, 22, -15, 11, -45, 33, 11, -3, 3, -31, -57, 14, -27, -7, -48, 4, 1, 20, -24, -21, 3, 25, -1, 1, 34, 4, -11, 15, -43, -28, -17, -6, -33, 10, -16, 10, 5, 30, -35, -57, 18, 16, -20, 43, -20, -38, -52, 15, -1, 15, -23, -18, -18, 24, -15, 28, 17, 2, 0, 5, -34, -21, 13, -14, -9, 29, -11, 8, 7, 16, -5, -23, 11, -8, -52, 13, 3, -4, -4, -30, 33, 16, -11, 15, 24, 3, -11, 31, 21, -34, -1, 36, 0, 8, -15, 8, -33, 46, -9, -3, -23, 41, -7, -63, 16, -61, -85, 17, -34, -47, -63, 17, 40, 22, -34, 22, 17, -14, 12, -17, 39, -87, -10, 21, -54, -10, -29, -33, -62, 30, -24, 
  -69, 66, -7, -58, -20, -21, 19, 36, 71, 35, -18, -13, 8, -22, -43, -30, 4, -37, -62, 9, 15, -21, -61, 0, 3, -29, 55, -23, -88, 70, -23, -17, -17, 41, -64, -71, -17, -8, 6, 22, 33, 20, -18, 10, 0, -22, -8, -38, -16, -22, -3, 1, 14, -8, -69, -14, -6, 1, 2, -8, -11, 49, -18, -1, 16, 35, -12, -52, -15, 15, 33, 33, 8, -7, 9, -6, -19, 3, 10, 18, -15, -7, 22, -21, 14, 4, 8, 11, -14, 18, -23, -4, 3, 30, 26, 8, -2, 61, 1, -57, -8, -6, -3, -1, 11, 23, 23, 15, -12, 1, -15, 8, -1, -6, -16, -19, -2, -25, -23, 2, 21, 7, 26, -23, -5, 77, 3, 15, -61, 79, -23, -20, 12, 6, 23, 57, 55, 40, 36, 24, 8, 11, 19, 11, 5, -38, -3, 24, 17, -28, 36, 10, -17, 45, 27, 6, 1, 64, -28, 7, 
};
const TfArray<2, int> tensor_dimension9 = { 2, { 4,160 } };
const TfArray<1, float> quant9_scale = { 1, { 0.0076199555769562721, } };
const TfArray<1, int> quant9_zero = { 1, { 0 } };
const TfLiteAffineQuantization quant9 = { (TfLiteFloatArray*)&quant9_scale, (TfLiteIntArray*)&quant9_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data10[32] = { -329, -340, 764, 818, -1072, 139, -195, 171, 297, 209, -1194, 73, -941, -61, 965, -1376, -674, 69, -123, -497, -847, 606, -926, 817, 1031, -1063, -42, -1019, -1283, -191, 427, 452, };
const TfArray<1, int> tensor_dimension10 = { 1, { 32 } };
const TfArray<32, float> quant10_scale = { 32, { 9.8606797109823674e-05, 0.00011895532952621579, 0.00011819836072390899, 0.00022053402790334076, 0.00014410202857106924, 9.6264229796361178e-05, 0.00015965287457220256, 0.00021575813298113644, 0.00031940589542500675, 0.00016662041889503598, 0.00013783411122858524, 0.0002106264146277681, 4.9714533815858886e-05, 0.00011740629997802898, 0.00012586826051119715, 9.7018448286689818e-05, 4.4519798393594101e-05, 0.00018523531616665423, 0.00013780404697172344, 5.4174139222595841e-05, 5.1852974138455465e-05, 0.00012118231097701937, 0.00013148074503988028, 0.00014613523671869189, 0.00018141642794944346, 0.00014886744611430913, 0.00011239925515837967, 6.2819439335726202e-05, 0.00015174748841673136, 0.00013983574172016233, 0.00010655970254447311, 0.00015273493772838265, } };
const TfArray<32, int> quant10_zero = { 32, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant10 = { (TfLiteFloatArray*)&quant10_scale, (TfLiteIntArray*)&quant10_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data11[32*1*3*16] = { 
  /* [0][0][][] */ 58,28,-30,-12,35,-43,52,-47,25,11,-87,-27,-13,-80,76,21, 31,37,41,15,-4,-61,86,8,-6,-61,-60,-114,-22,-40,93,-31, 12,18,68,16,-103,0,17,82,91,-42,-78,-107,-18,-127,28,45, 
  /* [1][0][][] */ 34,-61,-29,0,37,-22,119,-32,-14,72,53,114,0,-9,27,-65, 29,-92,-53,-20,51,-7,55,-60,45,103,102,107,40,-65,20,-126, 22,-44,-19,-2,26,0,55,-89,10,92,72,88,54,-127,70,-38, 
  /* [2][0][][] */ -81,36,65,-12,-9,27,23,90,50,-53,-7,-125,-8,-82,58,60, -51,26,54,44,-127,-29,-2,-1,-11,7,-19,-85,-58,-58,-38,8, -27,28,-26,-5,-16,-73,-25,7,-12,9,-36,-47,-21,-80,12,48, 
  /* [3][0][][] */ -5,-8,-19,22,-1,-47,-13,-17,-30,-26,-7,20,9,89,-20,-56, -22,50,4,21,-48,-37,-3,-6,-25,-21,-2,63,5,127,-62,-55, -40,-19,-36,-20,-27,-57,7,-32,-48,-16,10,-9,-5,81,-15,-43, 
  /* [4][0][][] */ 64,5,4,-31,63,-60,88,-25,-60,-22,-26,11,-30,80,59,18, 62,-20,-30,-30,127,-5,23,24,-83,-1,-58,-59,16,70,61,30, -13,-5,-23,-6,40,-68,-20,-43,-29,-50,-38,-58,-52,-36,-18,-33, 
  /* [5][0][][] */ -65,-28,-22,-20,-92,-28,5,-21,0,31,-60,-38,-59,-107,-38,0, 10,-39,-27,-38,63,-8,29,46,18,-29,-73,-47,-65,-100,64,-16, 21,44,63,34,57,34,37,88,58,69,-25,-31,-50,-127,34,56, 
  /* [6][0][][] */ 58,-41,-33,-29,-2,-18,52,-13,19,62,19,48,-25,-61,5,-50, 15,-32,-37,-15,25,-5,30,-7,29,42,1,65,-7,-11,33,-29, 87,-62,18,-24,127,37,77,-1,-18,91,41,48,44,-12,51,-19, 
  /* [7][0][][] */ 7,-27,-38,-18,-37,0,47,-16,-3,36,40,38,18,83,-5,-46, 9,15,-25,-5,9,-20,35,-51,-28,4,-8,51,55,127,-14,-41, 31,21,-27,24,-20,-18,13,-45,-12,35,34,59,10,59,32,-24, 
  /* [8][0][][] */ -2,5,-7,12,-49,3,27,14,7,56,10,12,10,-127,15,17, -26,-5,-2,-8,19,3,12,-28,16,44,11,22,-12,-59,9,-24, 6,-3,3,2,24,-8,28,-6,10,75,37,-7,8,-22,24,-9, 
  /* [9][0][][] */ -27,-3,-30,-39,-18,-32,45,-11,-2,22,16,32,51,37,-3,-18, -16,4,-11,-1,22,10,13,-52,18,-25,39,50,65,127,9,-78, 4,-50,13,39,-5,-14,28,-23,-27,43,92,111,67,54,11,-23, 
  /* [10][0][][] */ 22,-12,-43,-78,29,4,99,14,5,63,-8,31,-36,77,21,7, 87,-64,-8,-31,127,32,28,39,-29,30,-48,-35,34,48,89,-4, -17,-34,-28,-18,-12,-47,14,-12,27,-13,-49,-71,-83,-24,-23,-31, 
  /* [11][0][][] */ -13,-2,-40,7,-25,-54,-17,-43,-3,-11,-9,13,-1,100,-4,-15, 13,26,-20,16,19,-38,6,-28,-20,-25,-17,54,25,127,-30,-34, 9,-33,-18,18,3,17,17,-11,-17,21,60,48,39,93,21,-58, 
  /* [12][0][][] */ -50,-37,-31,18,-46,-28,-67,-98,-17,-63,47,30,75,-15,1,-27, -122,-7,17,-79,89,24,-29,-114,-88,-34,61,-127,-125,67,80,-11, -37,32,-85,-36,-102,32,91,-86,-67,-71,37,40,30,-104,45,-85, 
  /* [13][0][][] */ -63,-48,10,-7,-11,19,32,-7,33,-3,-7,-77,-75,-92,101,-13, -5,-41,44,21,-35,12,-21,46,-39,17,-46,-98,-13,-123,30,10, -34,52,65,8,-3,6,30,-4,53,-1,-74,-31,-50,-127,31,82, 
  /* [14][0][][] */ -73,47,41,59,4,47,-39,-23,-5,-29,71,57,29,-67,-10,5, -32,29,41,-5,-50,-34,-47,-29,47,1,-3,-9,36,-52,-22,29, -81,11,25,-14,-68,-32,-79,9,-22,-88,-48,-84,60,127,-8,45, 
  /* [15][0][][] */ 63,1,51,-70,4,-51,85,-43,-28,41,4,-51,-83,127,2,0, 112,-39,24,-55,84,1,71,78,-70,-54,-27,-48,5,-56,110,62, 79,-83,-61,-118,12,-16,58,52,-75,-34,-82,-6,-114,109,60,10, 
  /* [16][0][][] */ -7,-67,17,-109,10,63,0,-36,-117,-93,25,21,-29,-40,58,-55, -98,-33,-90,-46,-69,-39,-26,46,-127,-94,43,-57,-110,-95,11,-122, 25,85,-73,-32,-93,45,-51,-109,-22,-34,-58,88,65,-42,-83,8, 
  /* [17][0][][] */ -45,39,-11,44,-29,-16,-52,-11,-10,-6,-10,3,11,57,-45,14, -20,3,4,28,-65,-2,-34,12,22,-37,-28,-19,19,83,-60,-8, -17,30,-20,44,-92,-32,-40,25,-15,-56,2,29,12,127,-46,-31, 
  /* [18][0][][] */ 57,9,39,-35,15,-33,16,-13,25,12,-36,-55,-33,-25,47,-16, 22,-16,19,-22,50,-9,-21,34,3,-22,-41,-45,2,-22,-37,27, 68,17,52,-3,125,-60,26,77,35,-33,-64,-62,-48,-127,52,53, 
  /* [19][0][][] */ 6,-110,44,-79,3,32,57,-110,-38,-101,81,-68,-10,91,-42,60, -51,36,-56,-115,-34,57,44,20,-27,-87,-23,-72,-64,-30,11,24, -29,-43,4,73,-30,-21,-127,-8,-52,-44,-83,-30,-57,-24,-26,16, 
  /* [20][0][][] */ -105,76,-111,39,17,-14,-65,-24,-2,-7,-45,-86,40,-10,72,4, -85,-123,64,-106,26,-71,9,80,-98,72,24,-59,39,-5,-52,-98, 66,79,-73,-127,-47,-71,15,-55,52,1,-70,12,16,55,-33,24, 
  /* [21][0][][] */ -56,0,2,46,-73,20,-39,2,3,27,-43,-24,-21,-90,-41,-2, -74,-23,49,13,-23,-8,-6,44,18,-5,-1,-1,-30,-116,35,8, -85,71,72,15,-127,0,24,64,64,-15,-53,-93,-36,-83,-58,47, 
  /* [22][0][][] */ -12,21,16,-24,13,-4,17,33,-35,-87,-19,-57,-75,30,-55,-22, 109,0,58,-93,127,-36,6,34,-18,-17,-108,-67,12,-2,60,11, 50,-17,4,-54,27,-80,-3,19,-61,-4,-107,-91,-83,91,-19,-5, 
  /* [23][0][][] */ -32,-10,-26,48,-61,7,9,-20,24,-9,74,54,3,57,-33,-9, -23,5,9,-29,-66,-29,10,7,11,-36,55,89,14,117,-2,5, -40,9,17,38,-67,14,3,-43,7,-1,59,121,74,127,-25,13, 
  /* [24][0][][] */ -63,22,-10,1,-23,22,-40,34,34,17,32,-15,-2,-104,-14,22, -12,20,3,46,-18,19,-59,4,-12,13,-6,-32,-17,-89,-15,8, -53,18,47,43,-53,-22,10,9,48,-17,-63,-19,-1,-127,-16,22, 
  /* [25][0][][] */ 42,-4,7,-22,10,-30,25,1,4,-7,-43,-27,-38,86,16,-38, 68,-22,1,-18,127,39,13,-13,-10,-6,-65,-9,19,51,55,39, 57,-83,-10,-48,46,-32,60,-6,-42,-7,-65,-43,-66,21,44,-19, 
  /* [26][0][][] */ 107,-32,6,-6,2,-23,86,-12,52,127,52,53,-39,-57,101,31, 81,-24,-24,-39,26,18,98,-62,-4,70,2,55,-43,-95,45,-84, 101,-53,28,-39,68,-4,123,-65,21,105,67,96,65,-51,47,15, 
  /* [27][0][][] */ 60,73,40,-68,15,-54,40,-70,-67,-76,-65,-61,-72,54,-39,-16, -34,-71,20,-103,-24,20,-74,-90,-4,-86,-58,-82,-19,-95,-81,-44, 11,-107,-110,9,-11,31,-7,24,-58,-127,76,-60,-9,-58,-56,21, 
  /* [28][0][][] */ 21,-30,-5,-14,18,-40,11,26,-21,-25,14,-15,-60,-20,-5,17, 62,11,-13,22,61,14,42,-12,7,-43,-38,-57,-66,13,35,-1, 90,-12,63,-20,127,45,64,75,54,-54,-38,-36,16,-63,70,51, 
  /* [29][0][][] */ 2,-42,-74,-71,8,-5,36,-18,-15,49,64,19,18,-127,-21,-79, 2,-34,22,-27,87,4,49,14,61,101,62,36,71,-34,40,-8, -19,-61,-74,-15,-18,26,116,-121,24,73,67,81,56,-72,39,-92, 
  /* [30][0][][] */ -34,12,-45,12,-18,-19,-48,-57,20,93,-52,-88,12,-9,84,-43, -45,42,37,-13,16,-4,-9,-35,44,-3,-42,-47,-63,-39,42,40, -22,29,20,32,-95,-5,-3,87,82,-39,-74,-58,-43,-127,-9,58, 
  /* [31][0][][] */ 12,42,-7,-17,-64,-5,-34,-28,-16,-86,34,36,8,87,-18,-74, -16,19,-7,-15,-28,17,-46,0,-31,-68,33,78,81,127,-42,-40, 26,-25,7,31,-44,-45,-8,-13,-38,-18,71,95,77,94,-37,-49, 
};
const TfArray<4, int> tensor_dimension11 = { 4, { 32,1,3,16 } };
const TfArray<32, float> quant11_scale = { 32, { 0.0038633453659713268, 0.0046605868265032768, 0.0046309293247759342, 0.0086403694003820419, 0.0056458166800439358, 0.003771565156057477, 0.0062550883740186691, 0.0084532527253031731, 0.012514100410044193, 0.0065280715934932232, 0.0054002441465854645, 0.0082521960139274597, 0.0019477807218208909, 0.0045998967252671719, 0.0049314307980239391, 0.0038011150900274515, 0.0017442546086385846, 0.0072573903016746044, 0.0053990660235285759, 0.0021225048694759607, 0.0020315633155405521, 0.0047478382475674152, 0.0051513235084712505, 0.0057254764251410961, 0.0071077686734497547, 0.0058325226418673992, 0.0044037243351340294, 0.0024612217675894499, 0.005945360753685236, 0.0054786666296422482, 0.0041749347001314163, 0.005984047893434763, } };
const TfArray<32, int> quant11_zero = { 32, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant11 = { (TfLiteFloatArray*)&quant11_scale, (TfLiteIntArray*)&quant11_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data12[16] = { -1728, 968, -228, 944, -1436, 1081, 1332, -935, -985, 2299, 1752, 880, 610, 1900, 581, -61, };
const TfArray<1, int> tensor_dimension12 = { 1, { 16 } };
const TfArray<16, float> quant12_scale = { 16, { 7.8860473877284676e-05, 4.6467801439575851e-05, 4.9374910304322839e-05, 4.6706489229109138e-05, 8.5694431618321687e-05, 3.9223952626343817e-05, 5.6603690609335899e-05, 5.4478288802783936e-05, 5.7705121434992179e-05, 6.4699612266849726e-05, 6.3288323872257024e-05, 8.3768696640618145e-05, 6.3808445702306926e-05, 9.5614137535449117e-05, 5.4962230933597311e-05, 7.3659415647853166e-05, } };
const TfArray<16, int> quant12_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant12 = { (TfLiteFloatArray*)&quant12_scale, (TfLiteIntArray*)&quant12_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data13[16*1*3*8] = { 
  /* [0][0][][] */ 5,26,69,33,-42,83,104,-11, 22,32,31,3,-75,83,127,-69, 52,50,34,29,-96,55,103,-34, 
  /* [1][0][][] */ 13,73,-8,5,0,-87,-53,57, -59,-64,-49,-52,127,29,21,113, 60,-36,14,-103,-3,-113,-56,-15, 
  /* [2][0][][] */ 69,64,47,-20,35,82,-19,89, 127,12,86,10,61,0,-18,104, 25,1,41,-72,29,-25,39,18, 
  /* [3][0][][] */ 82,-8,47,-41,126,-51,-127,51, 51,-57,-2,55,-28,-96,-92,40, -56,1,-42,-56,56,-89,-12,27, 
  /* [4][0][][] */ -31,-30,3,-27,-6,-4,28,-20, -22,25,6,-31,-38,85,64,-34, 87,97,65,-24,-19,127,59,-20, 
  /* [5][0][][] */ -127,9,90,88,-31,-119,-106,91, -104,-26,1,26,-54,87,-28,42, -24,93,104,38,-42,64,-51,86, 
  /* [6][0][][] */ -15,-6,42,68,-98,125,46,-33, -1,-18,34,16,-64,127,-3,-9, -73,-28,-54,113,-22,124,-66,-62, 
  /* [7][0][][] */ 61,103,73,-80,-15,120,36,48, 95,84,127,35,46,97,32,86, 108,-25,-2,-45,63,39,92,71, 
  /* [8][0][][] */ 97,-50,111,52,6,-2,-53,63, 36,-68,-2,54,36,-52,-127,107, 59,-73,40,43,30,-13,-50,2, 
  /* [9][0][][] */ 13,-122,25,113,-42,-21,-25,15, -59,-114,-36,58,-39,13,-44,-8, -37,-127,-68,116,-23,0,-97,-3, 
  /* [10][0][][] */ -59,26,-19,71,38,10,-42,-33, -99,5,-38,48,-44,14,-127,-37, -57,-4,-84,84,-68,61,-72,16, 
  /* [11][0][][] */ -85,6,-35,79,3,20,-58,-50, -28,-2,-23,45,64,21,-89,-11, -127,7,-84,72,-95,-8,-90,-37, 
  /* [12][0][][] */ -127,30,-81,71,16,26,-22,-1, -40,-1,-93,6,-117,57,-87,-47, 70,13,-32,44,67,-32,-65,2, 
  /* [13][0][][] */ -51,-17,9,-103,41,1,-12,-47, -70,-36,-74,-62,-127,-80,34,-43, 22,-19,32,-57,93,-47,45,-32, 
  /* [14][0][][] */ 1,-7,67,5,-47,127,70,-63, 14,58,104,64,-49,81,94,-68, 120,-67,45,114,-8,42,59,-66, 
  /* [15][0][][] */ 76,72,59,-14,10,38,-28,69, 127,15,88,-10,12,13,20,61, 54,-50,71,-36,5,39,2,46, 
};
const TfArray<4, int> tensor_dimension13 = { 4, { 16,1,3,8 } };
const TfArray<16, float> quant13_scale = { 16, { 0.0064483205787837505, 0.0037996128667145967, 0.0040373234078288078, 0.003819130128249526, 0.0070071243681013584, 0.003207292640581727, 0.0046284114941954613, 0.0044546201825141907, 0.0047184741124510765, 0.0052904048934578896, 0.0051750056445598602, 0.0068496591411530972, 0.0052175354212522507, 0.0078182462602853775, 0.004494191613048315, 0.006023036316037178, } };
const TfArray<16, int> quant13_zero = { 16, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant13 = { (TfLiteFloatArray*)&quant13_scale, (TfLiteIntArray*)&quant13_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int32_t tensor_data14[8] = { 2030, -1997, -1438, 4102, 7982, -3432, 4058, 3912, };
const TfArray<1, int> tensor_dimension14 = { 1, { 8 } };
const TfArray<8, float> quant14_scale = { 8, { 2.0434903490240686e-05, 1.53090622916352e-05, 2.3825179596315138e-05, 2.441884862491861e-05, 2.0656036213040352e-05, 2.1746152924606577e-05, 3.2165444281417876e-05, 1.9060909835388884e-05, } };
const TfArray<8, int> quant14_zero = { 8, { 0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant14 = { (TfLiteFloatArray*)&quant14_scale, (TfLiteIntArray*)&quant14_zero, 0 };
const MODEL_SECTION(EI_MODEL_SECTION) ALIGN(16) int8_t tensor_data15[8*1*3*32] = { 
  /* [0][0][][] */ -19,41,-4,20,-15,9,39,39,-76,-52,-2,-85,29,-106,-97,-32,-33,-33,10,-4,25,24,13,69,30,-11,20,-5,22,-63,-70,13, 1,21,46,2,-25,15,-47,42,-91,-25,-32,27,12,-78,-4,6,-4,-13,77,83,-13,80,67,127,70,24,10,48,-6,12,22,-15, -61,-41,33,-22,24,1,-24,65,-105,-70,-7,1,72,7,-22,15,22,-29,47,1,56,-24,-22,16,-28,-26,-65,-61,-21,-101,-96,-69, 
  /* [1][0][][] */ 14,8,93,127,-29,55,-47,20,-84,-26,2,-27,62,-30,50,13,-66,-51,67,79,63,38,36,46,28,-49,-42,11,-10,-2,-13,-89, 59,90,94,111,5,38,1,-64,-38,-37,-31,9,-22,72,27,52,9,-63,-14,9,64,18,-88,57,25,-62,-21,12,51,48,-40,-27, 25,64,94,78,5,107,0,-21,-108,13,-14,-25,-14,2,-15,-46,63,-65,28,24,14,124,45,64,4,36,-21,88,96,-16,7,35, 
  /* [2][0][][] */ 53,64,12,20,-16,-67,9,-17,-86,-68,10,-42,67,-90,-60,-12,21,-47,16,20,57,15,3,22,20,-32,-31,-28,15,-23,-19,17, -24,73,89,43,-24,-24,-23,-59,-74,-35,12,-19,43,-30,-47,-72,12,-69,8,-46,-12,19,53,54,-18,-34,18,17,20,36,-5,15, 11,87,62,48,-53,5,-22,1,-127,-29,22,-42,-33,-66,-108,-85,6,-58,-23,8,55,31,59,76,42,-28,-36,-10,43,39,22,40, 
  /* [3][0][][] */ -127,-1,-12,-79,-34,-96,-54,-17,76,13,-26,-77,-4,19,24,-13,37,-9,-10,-10,17,8,39,20,5,55,35,-76,-33,-27,21,36, -83,25,-34,-32,-44,-87,-112,31,31,56,-1,-60,26,13,50,-21,30,8,-38,-27,-29,-41,47,-14,48,64,11,-17,-29,-16,10,60, -51,4,-27,-91,-53,-114,-73,24,61,66,-5,-63,-6,-34,51,-25,31,-17,13,-45,23,18,39,15,-18,55,64,-41,-68,-14,-8,35, 
  /* [4][0][][] */ 10,-49,23,74,-9,32,28,45,-81,-43,-34,40,10,29,-14,27,-37,-31,-28,-32,-42,-51,-20,1,-49,-24,-7,30,50,0,-61,-20, -60,-87,-7,-69,-54,33,-17,14,-58,-72,-26,-38,-31,-32,-22,-60,-10,-49,-22,12,-49,-4,-8,-8,-39,-11,6,-2,0,33,4,-7, -44,-16,14,28,53,114,71,127,22,-22,68,81,41,82,5,35,80,-6,-12,24,1,-2,44,30,4,-11,4,66,81,81,-31,-5, 
  /* [5][0][][] */ 41,-7,-18,1,13,-29,-37,-42,-83,-29,-75,29,6,5,-52,-36,-56,-1,-18,22,34,60,85,-23,-25,-62,-35,-31,-67,-1,-95,-25, 72,29,41,27,16,19,25,-56,-127,-70,-23,24,-13,-20,-53,-63,-46,-36,-62,-66,27,82,31,22,-25,-38,-3,-4,1,-50,-35,-29, 30,74,13,59,35,40,-30,-51,-110,-34,-74,-35,-24,8,-37,-55,15,-43,8,-29,35,64,32,-1,-24,6,-10,-14,-32,-3,-70,-24, 
  /* [6][0][][] */ 29,-6,-11,-3,6,-59,-7,-66,-127,-56,-56,9,-23,-47,-40,-27,-98,-10,-30,-24,1,43,24,52,-8,-25,8,-1,-2,-77,-27,-27, 38,-42,-28,27,25,53,35,-12,-70,-107,-29,-7,-31,-4,-25,-5,-40,-1,-18,19,14,54,73,67,40,-57,-55,-20,-29,-86,-33,-30, -4,15,-3,32,47,-15,23,-11,-36,-12,-31,43,18,-9,-35,-11,-57,-4,-36,-29,38,58,63,73,81,-3,-111,-52,-58,-77,-97,-64, 
  /* [7][0][][] */ 45,-69,53,55,-15,-10,-38,78,-127,-18,52,-44,107,-34,-18,-12,8,12,11,32,-66,-11,-19,19,21,-17,27,97,108,65,-15,-42, 5,-9,59,34,16,-3,75,69,-114,-57,-42,-26,-1,-6,19,16,41,2,76,-19,-44,-35,-43,-35,-69,-65,-2,-22,20,10,-13,-26, 29,-93,22,68,-52,-1,-30,41,-48,-24,41,12,65,42,-23,-49,-5,-71,33,21,-90,-28,-3,31,-10,-8,-8,25,28,27,-14,-9, 
};
const TfArray<4, int> tensor_dimension15 = { 4, { 8,1,3,32 } };
const TfArray<8, float> quant15_scale = { 8, { 0.0052313352935016155, 0.0039191199466586113, 0.0060992459766566753, 0.0062512252479791641, 0.0052879452705383301, 0.0055670151486992836, 0.0082343537360429764, 0.0048795929178595543, } };
const TfArray<8, int> quant15_zero = { 8, { 0,0,0,0,0,0,0,0 } };
const TfLiteAffineQuantization quant15 = { (TfLiteFloatArray*)&quant15_scale, (TfLiteIntArray*)&quant15_zero, 0 };
const TfArray<4, int> tensor_dimension16 = { 4, { 1,1,40,32 } };
const TfArray<1, float> quant16_scale = { 1, { 0.00390625, } };
const TfArray<1, int> quant16_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant16 = { (TfLiteFloatArray*)&quant16_scale, (TfLiteIntArray*)&quant16_zero, 0 };
const TfArray<4, int> tensor_dimension17 = { 4, { 1,1,40,8 } };
const TfArray<1, float> quant17_scale = { 1, { 0.012229614891111851, } };
const TfArray<1, int> quant17_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant17 = { (TfLiteFloatArray*)&quant17_scale, (TfLiteIntArray*)&quant17_zero, 0 };
const TfArray<4, int> tensor_dimension18 = { 4, { 1,40,1,8 } };
const TfArray<1, float> quant18_scale = { 1, { 0.012229614891111851, } };
const TfArray<1, int> quant18_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant18 = { (TfLiteFloatArray*)&quant18_scale, (TfLiteIntArray*)&quant18_zero, 0 };
const TfArray<4, int> tensor_dimension19 = { 4, { 1,20,1,8 } };
const TfArray<1, float> quant19_scale = { 1, { 0.012229614891111851, } };
const TfArray<1, int> quant19_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant19 = { (TfLiteFloatArray*)&quant19_scale, (TfLiteIntArray*)&quant19_zero, 0 };
const TfArray<4, int> tensor_dimension20 = { 4, { 1,1,20,8 } };
const TfArray<1, float> quant20_scale = { 1, { 0.012229614891111851, } };
const TfArray<1, int> quant20_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant20 = { (TfLiteFloatArray*)&quant20_scale, (TfLiteIntArray*)&quant20_zero, 0 };
const TfArray<4, int> tensor_dimension21 = { 4, { 1,1,20,16 } };
const TfArray<1, float> quant21_scale = { 1, { 0.025523681193590164, } };
const TfArray<1, int> quant21_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant21 = { (TfLiteFloatArray*)&quant21_scale, (TfLiteIntArray*)&quant21_zero, 0 };
const TfArray<4, int> tensor_dimension22 = { 4, { 1,20,1,16 } };
const TfArray<1, float> quant22_scale = { 1, { 0.025523681193590164, } };
const TfArray<1, int> quant22_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant22 = { (TfLiteFloatArray*)&quant22_scale, (TfLiteIntArray*)&quant22_zero, 0 };
const TfArray<4, int> tensor_dimension23 = { 4, { 1,10,1,16 } };
const TfArray<1, float> quant23_scale = { 1, { 0.025523681193590164, } };
const TfArray<1, int> quant23_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant23 = { (TfLiteFloatArray*)&quant23_scale, (TfLiteIntArray*)&quant23_zero, 0 };
const TfArray<4, int> tensor_dimension24 = { 4, { 1,1,10,16 } };
const TfArray<1, float> quant24_scale = { 1, { 0.025523681193590164, } };
const TfArray<1, int> quant24_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant24 = { (TfLiteFloatArray*)&quant24_scale, (TfLiteIntArray*)&quant24_zero, 0 };
const TfArray<4, int> tensor_dimension25 = { 4, { 1,1,10,32 } };
const TfArray<1, float> quant25_scale = { 1, { 0.073244810104370117, } };
const TfArray<1, int> quant25_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant25 = { (TfLiteFloatArray*)&quant25_scale, (TfLiteIntArray*)&quant25_zero, 0 };
const TfArray<4, int> tensor_dimension26 = { 4, { 1,10,1,32 } };
const TfArray<1, float> quant26_scale = { 1, { 0.073244810104370117, } };
const TfArray<1, int> quant26_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant26 = { (TfLiteFloatArray*)&quant26_scale, (TfLiteIntArray*)&quant26_zero, 0 };
const TfArray<4, int> tensor_dimension27 = { 4, { 1,5,1,32 } };
const TfArray<1, float> quant27_scale = { 1, { 0.073244810104370117, } };
const TfArray<1, int> quant27_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant27 = { (TfLiteFloatArray*)&quant27_scale, (TfLiteIntArray*)&quant27_zero, 0 };
const TfArray<2, int> tensor_dimension28 = { 2, { 1,160 } };
const TfArray<1, float> quant28_scale = { 1, { 0.073244810104370117, } };
const TfArray<1, int> quant28_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant28 = { (TfLiteFloatArray*)&quant28_scale, (TfLiteIntArray*)&quant28_zero, 0 };
const TfArray<2, int> tensor_dimension29 = { 2, { 1,4 } };
const TfArray<1, float> quant29_scale = { 1, { 1.3192161321640015, } };
const TfArray<1, int> quant29_zero = { 1, { 34 } };
const TfLiteAffineQuantization quant29 = { (TfLiteFloatArray*)&quant29_scale, (TfLiteIntArray*)&quant29_zero, 0 };
const TfArray<2, int> tensor_dimension30 = { 2, { 1,4 } };
const TfArray<1, float> quant30_scale = { 1, { 0.00390625, } };
const TfArray<1, int> quant30_zero = { 1, { -128 } };
const TfLiteAffineQuantization quant30 = { (TfLiteFloatArray*)&quant30_scale, (TfLiteIntArray*)&quant30_zero, 0 };
const TfLiteReshapeParams opdata0 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs0 = { 2, { 0,1 } };
const TfArray<1, int> outputs0 = { 1, { 16 } };
const TfLiteConvParams opdata1 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs1 = { 3, { 16,15,14 } };
const TfArray<1, int> outputs1 = { 1, { 17 } };
const TfLiteReshapeParams opdata2 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs2 = { 2, { 17,2 } };
const TfArray<1, int> outputs2 = { 1, { 18 } };
const TfLitePoolParams opdata3 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs3 = { 1, { 18 } };
const TfArray<1, int> outputs3 = { 1, { 19 } };
const TfLiteReshapeParams opdata4 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs4 = { 2, { 19,3 } };
const TfArray<1, int> outputs4 = { 1, { 20 } };
const TfLiteConvParams opdata5 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs5 = { 3, { 20,13,12 } };
const TfArray<1, int> outputs5 = { 1, { 21 } };
const TfLiteReshapeParams opdata6 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs6 = { 2, { 21,4 } };
const TfArray<1, int> outputs6 = { 1, { 22 } };
const TfLitePoolParams opdata7 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs7 = { 1, { 22 } };
const TfArray<1, int> outputs7 = { 1, { 23 } };
const TfLiteReshapeParams opdata8 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs8 = { 2, { 23,5 } };
const TfArray<1, int> outputs8 = { 1, { 24 } };
const TfLiteConvParams opdata9 = { kTfLitePaddingSame, 1,1, kTfLiteActRelu, 1,1 };
const TfArray<3, int> inputs9 = { 3, { 24,11,10 } };
const TfArray<1, int> outputs9 = { 1, { 25 } };
const TfLiteReshapeParams opdata10 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs10 = { 2, { 25,6 } };
const TfArray<1, int> outputs10 = { 1, { 26 } };
const TfLitePoolParams opdata11 = { kTfLitePaddingSame, 1,2, 1,2, kTfLiteActNone, { { 0,0, 0, 0 } } };
const TfArray<1, int> inputs11 = { 1, { 26 } };
const TfArray<1, int> outputs11 = { 1, { 27 } };
const TfLiteReshapeParams opdata12 = { { 0, 0, 0, 0, 0, 0, 0, 0, }, 0 };
const TfArray<2, int> inputs12 = { 2, { 27,7 } };
const TfArray<1, int> outputs12 = { 1, { 28 } };
const TfLiteFullyConnectedParams opdata13 = { kTfLiteActNone, kTfLiteFullyConnectedWeightsFormatDefault, false, false };
const TfArray<3, int> inputs13 = { 3, { 28,9,8 } };
const TfArray<1, int> outputs13 = { 1, { 29 } };
const TfLiteSoftmaxParams opdata14 = { 1 };
const TfArray<1, int> inputs14 = { 1, { 29 } };
const TfArray<1, int> outputs14 = { 1, { 30 } };
};

TensorInfo_t tensorData[] = {
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 1280), (TfLiteIntArray*)&g0::tensor_dimension0, 1280, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant0))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data1, (TfLiteIntArray*)&g0::tensor_dimension1, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data2, (TfLiteIntArray*)&g0::tensor_dimension2, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data3, (TfLiteIntArray*)&g0::tensor_dimension3, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data4, (TfLiteIntArray*)&g0::tensor_dimension4, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data5, (TfLiteIntArray*)&g0::tensor_dimension5, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data6, (TfLiteIntArray*)&g0::tensor_dimension6, 16, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data7, (TfLiteIntArray*)&g0::tensor_dimension7, 8, {kTfLiteNoQuantization, nullptr}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data8, (TfLiteIntArray*)&g0::tensor_dimension8, 16, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant8))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data9, (TfLiteIntArray*)&g0::tensor_dimension9, 640, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant9))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data10, (TfLiteIntArray*)&g0::tensor_dimension10, 128, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant10))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data11, (TfLiteIntArray*)&g0::tensor_dimension11, 1536, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant11))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data12, (TfLiteIntArray*)&g0::tensor_dimension12, 64, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant12))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data13, (TfLiteIntArray*)&g0::tensor_dimension13, 384, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant13))}, },
{ kTfLiteMmapRo, kTfLiteInt32, (int32_t*)g0::tensor_data14, (TfLiteIntArray*)&g0::tensor_dimension14, 32, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant14))}, },
{ kTfLiteMmapRo, kTfLiteInt8, (int32_t*)g0::tensor_data15, (TfLiteIntArray*)&g0::tensor_dimension15, 768, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant15))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension16, 1280, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant16))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 1664), (TfLiteIntArray*)&g0::tensor_dimension17, 320, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant17))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension18, 320, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant18))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 320), (TfLiteIntArray*)&g0::tensor_dimension19, 160, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant19))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension20, 160, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant20))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 320), (TfLiteIntArray*)&g0::tensor_dimension21, 320, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant21))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension22, 320, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant22))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 320), (TfLiteIntArray*)&g0::tensor_dimension23, 160, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant23))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 640), (TfLiteIntArray*)&g0::tensor_dimension24, 160, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant24))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 320), (TfLiteIntArray*)&g0::tensor_dimension25, 320, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant25))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension26, 320, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant26))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 320), (TfLiteIntArray*)&g0::tensor_dimension27, 160, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant27))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension28, 160, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant28))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 160), (TfLiteIntArray*)&g0::tensor_dimension29, 4, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant29))}, },
{ kTfLiteArenaRw, kTfLiteInt8, (int32_t*)(tensor_arena + 0), (TfLiteIntArray*)&g0::tensor_dimension30, 4, {kTfLiteAffineQuantization, const_cast<void*>(static_cast<const void*>(&g0::quant30))}, },
};

#ifndef TF_LITE_STATIC_MEMORY
TfLiteNode tflNodes[15] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs4, (TfLiteIntArray*)&g0::outputs4, (TfLiteIntArray*)&g0::inputs4, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata4)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs5, (TfLiteIntArray*)&g0::outputs5, (TfLiteIntArray*)&g0::inputs5, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata5)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs6, (TfLiteIntArray*)&g0::outputs6, (TfLiteIntArray*)&g0::inputs6, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata6)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs7, (TfLiteIntArray*)&g0::outputs7, (TfLiteIntArray*)&g0::inputs7, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata7)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs8, (TfLiteIntArray*)&g0::outputs8, (TfLiteIntArray*)&g0::inputs8, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata8)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs9, (TfLiteIntArray*)&g0::outputs9, (TfLiteIntArray*)&g0::inputs9, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata9)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs10, (TfLiteIntArray*)&g0::outputs10, (TfLiteIntArray*)&g0::inputs10, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata10)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs11, (TfLiteIntArray*)&g0::outputs11, (TfLiteIntArray*)&g0::inputs11, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata11)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs12, (TfLiteIntArray*)&g0::outputs12, (TfLiteIntArray*)&g0::inputs12, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata12)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs13, (TfLiteIntArray*)&g0::outputs13, (TfLiteIntArray*)&g0::inputs13, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata13)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs14, (TfLiteIntArray*)&g0::outputs14, (TfLiteIntArray*)&g0::inputs14, nullptr, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata14)), nullptr, 0, },
};
#else
TfLiteNode tflNodes[15] = {
{ (TfLiteIntArray*)&g0::inputs0, (TfLiteIntArray*)&g0::outputs0, (TfLiteIntArray*)&g0::inputs0, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata0)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs1, (TfLiteIntArray*)&g0::outputs1, (TfLiteIntArray*)&g0::inputs1, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata1)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs2, (TfLiteIntArray*)&g0::outputs2, (TfLiteIntArray*)&g0::inputs2, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata2)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs3, (TfLiteIntArray*)&g0::outputs3, (TfLiteIntArray*)&g0::inputs3, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata3)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs4, (TfLiteIntArray*)&g0::outputs4, (TfLiteIntArray*)&g0::inputs4, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata4)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs5, (TfLiteIntArray*)&g0::outputs5, (TfLiteIntArray*)&g0::inputs5, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata5)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs6, (TfLiteIntArray*)&g0::outputs6, (TfLiteIntArray*)&g0::inputs6, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata6)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs7, (TfLiteIntArray*)&g0::outputs7, (TfLiteIntArray*)&g0::inputs7, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata7)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs8, (TfLiteIntArray*)&g0::outputs8, (TfLiteIntArray*)&g0::inputs8, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata8)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs9, (TfLiteIntArray*)&g0::outputs9, (TfLiteIntArray*)&g0::inputs9, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata9)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs10, (TfLiteIntArray*)&g0::outputs10, (TfLiteIntArray*)&g0::inputs10, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata10)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs11, (TfLiteIntArray*)&g0::outputs11, (TfLiteIntArray*)&g0::inputs11, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata11)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs12, (TfLiteIntArray*)&g0::outputs12, (TfLiteIntArray*)&g0::inputs12, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata12)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs13, (TfLiteIntArray*)&g0::outputs13, (TfLiteIntArray*)&g0::inputs13, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata13)), nullptr, 0, },
{ (TfLiteIntArray*)&g0::inputs14, (TfLiteIntArray*)&g0::outputs14, (TfLiteIntArray*)&g0::inputs14, nullptr, const_cast<void*>(static_cast<const void*>(&g0::opdata14)), nullptr, 0, },
};
#endif

used_operators_e used_ops[] =
{OP_RESHAPE, OP_CONV_2D, OP_RESHAPE, OP_MAX_POOL_2D, OP_RESHAPE, OP_CONV_2D, OP_RESHAPE, OP_MAX_POOL_2D, OP_RESHAPE, OP_CONV_2D, OP_RESHAPE, OP_MAX_POOL_2D, OP_RESHAPE, OP_FULLY_CONNECTED, OP_SOFTMAX, };


// Indices into tflTensors and tflNodes for subgraphs
const size_t tflTensors_subgraph_index[] = {0, 31, };
const size_t tflNodes_subgraph_index[] = {0, 15, };

// Input/output tensors
static const int in_tensor_indices[] = {
  0, 
};

static const int out_tensor_indices[] = {
  30, 
};


size_t current_subgraph_index = 0;

static void init_tflite_tensor(size_t i, TfLiteTensor *tensor) {
  tensor->type = tensorData[i].type;
  tensor->is_variable = false;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  tensor->allocation_type = tensorData[i].allocation_type;
#else
  tensor->allocation_type = (tensor_arena <= tensorData[i].data && tensorData[i].data < tensor_arena + kTensorArenaSize) ? kTfLiteArenaRw : kTfLiteMmapRo;
#endif
  tensor->bytes = tensorData[i].bytes;
  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  if(tensor->allocation_type == kTfLiteArenaRw){
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
      tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
  tensor->quantization = tensorData[i].quantization;
  if (tensor->quantization.type == kTfLiteAffineQuantization) {
    TfLiteAffineQuantization const* quant = ((TfLiteAffineQuantization const*)(tensorData[i].quantization.params));
    tensor->params.scale = quant->scale->data[0];
    tensor->params.zero_point = quant->zero_point->data[0];
  }

}

static void init_tflite_eval_tensor(int i, TfLiteEvalTensor *tensor) {

  tensor->type = tensorData[i].type;

  tensor->dims = tensorData[i].dims;

#if defined(EI_CLASSIFIER_ALLOCATION_HEAP)
  auto allocation_type = tensorData[i].allocation_type;
  if(allocation_type == kTfLiteArenaRw) {
    uint8_t* start = (uint8_t*) ((uintptr_t)tensorData[i].data + (uintptr_t) tensor_arena);

    tensor->data.data =  start;
  }
  else {
    tensor->data.data = tensorData[i].data;
  }
#else
  tensor->data.data = tensorData[i].data;
#endif // EI_CLASSIFIER_ALLOCATION_HEAP
}

static void* overflow_buffers[EI_MAX_OVERFLOW_BUFFER_COUNT];
static size_t overflow_buffers_ix = 0;
static void * AllocatePersistentBufferImpl(struct TfLiteContext* ctx,
                                       size_t bytes) {
  void *ptr;
  uint32_t align_bytes = (bytes % 16) ? 16 - (bytes % 16) : 0;

  if (current_location - (bytes + align_bytes) < tensor_boundary) {
    if (overflow_buffers_ix > EI_MAX_OVERFLOW_BUFFER_COUNT - 1) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d, does not fit in tensor arena and reached EI_MAX_OVERFLOW_BUFFER_COUNT\n",
        (int)bytes);
      return NULL;
    }

    // OK, this will look super weird, but.... we have CMSIS-NN buffers which
    // we cannot calculate beforehand easily.
    ptr = ei_calloc(bytes, 1);
    if (ptr == NULL) {
      ei_printf("ERR: Failed to allocate persistent buffer of size %d\n", (int)bytes);
      return NULL;
    }
    overflow_buffers[overflow_buffers_ix++] = ptr;
    return ptr;
  }

  current_location -= bytes;

  // align to the left aligned boundary of 16 bytes
  current_location -= 15; // for alignment
  current_location += 16 - ((uintptr_t)(current_location) & 15);

  ptr = current_location;
  memset(ptr, 0, bytes);

  return ptr;
}

typedef struct {
  size_t bytes;
  void *ptr;
} scratch_buffer_t;

static scratch_buffer_t scratch_buffers[EI_MAX_SCRATCH_BUFFER_COUNT];
static size_t scratch_buffers_ix = 0;

static TfLiteStatus RequestScratchBufferInArenaImpl(struct TfLiteContext* ctx, size_t bytes,
                                                int* buffer_idx) {
  if (scratch_buffers_ix > EI_MAX_SCRATCH_BUFFER_COUNT - 1) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d, reached EI_MAX_SCRATCH_BUFFER_COUNT\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffer_t b;
  b.bytes = bytes;

  b.ptr = AllocatePersistentBufferImpl(ctx, b.bytes);
  if (!b.ptr) {
    ei_printf("ERR: Failed to allocate scratch buffer of size %d\n",
      (int)bytes);
    return kTfLiteError;
  }

  scratch_buffers[scratch_buffers_ix] = b;
  *buffer_idx = scratch_buffers_ix;

  scratch_buffers_ix++;

  return kTfLiteOk;
}

static void* GetScratchBufferImpl(struct TfLiteContext* ctx, int buffer_idx) {
  if (buffer_idx > (int)scratch_buffers_ix) {
    return NULL;
  }
  return scratch_buffers[buffer_idx].ptr;
}

static const uint16_t TENSOR_IX_UNUSED = 0x7FFF;

static void ResetTensors() {
  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    tflTensors[ix].index = TENSOR_IX_UNUSED;
  }
  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    tflEvalTensors[ix].index = TENSOR_IX_UNUSED;
  }
}

static TfLiteTensor* GetTensorImpl(const struct TfLiteContext* context,
                               int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_TENSOR_COUNT; ix++) {
    // already used? OK!
    if (tflTensors[ix].index == tensor_idx) {
      return &tflTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_tensor(tensor_idx, &tflTensors[ix].tensor);
      tflTensors[ix].index = tensor_idx;
      return &tflTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_TENSOR_COUNT (%d)\n", MAX_TFL_TENSOR_COUNT);
  return nullptr;
}

static TfLiteEvalTensor* GetEvalTensorImpl(const struct TfLiteContext* context,
                                       int tensor_idx) {

  tensor_idx = tflTensors_subgraph_index[current_subgraph_index] + tensor_idx;

  for (size_t ix = 0; ix < MAX_TFL_EVAL_COUNT; ix++) {
    // already used? OK!
    if (tflEvalTensors[ix].index == tensor_idx) {
      return &tflEvalTensors[ix].tensor;
    }
    // passed all the ones we've used, so end of the list?
    if (tflEvalTensors[ix].index == TENSOR_IX_UNUSED) {
      // init the tensor
      init_tflite_eval_tensor(tensor_idx, &tflEvalTensors[ix].tensor);
      tflEvalTensors[ix].index = tensor_idx;
      return &tflEvalTensors[ix].tensor;
    }
  }

  ei_printf("ERR: GetTensor called beyond MAX_TFL_EVAL_COUNT (%d)\n", (int)MAX_TFL_EVAL_COUNT);
  return nullptr;
}

class EonMicroContext : public MicroContext {
 public:
 
  EonMicroContext(): MicroContext(nullptr, nullptr, nullptr) { }

  void* AllocatePersistentBuffer(size_t bytes) {
    return AllocatePersistentBufferImpl(nullptr, bytes);
  }

  TfLiteStatus RequestScratchBufferInArena(size_t bytes,
                                           int* buffer_index) {
  return RequestScratchBufferInArenaImpl(nullptr, bytes, buffer_index);
  }

  void* GetScratchBuffer(int buffer_index) {
    return GetScratchBufferImpl(nullptr, buffer_index);
  }
 
  TfLiteTensor* AllocateTempTfLiteTensor(int tensor_index) {
    return GetTensorImpl(nullptr, tensor_index);
  }

  void DeallocateTempTfLiteTensor(TfLiteTensor* tensor) {
    return;
  }

  bool IsAllTempTfLiteTensorDeallocated() {
    return true;
  }

  TfLiteEvalTensor* GetEvalTensor(int tensor_index) {
    return GetEvalTensorImpl(nullptr, tensor_index);
  }

};


} // namespace

TfLiteStatus tflite_learn_5269_init( void*(*alloc_fnc)(size_t,size_t) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  tensor_arena = (uint8_t*) alloc_fnc(16, kTensorArenaSize);
  if (!tensor_arena) {
    ei_printf("ERR: failed to allocate tensor arena\n");
    return kTfLiteError;
  }
#else
  memset(tensor_arena, 0, kTensorArenaSize);
#endif
  tensor_boundary = tensor_arena;
  current_location = tensor_arena + kTensorArenaSize;

  EonMicroContext micro_context_;
  
  // Set microcontext as the context ptr
  ctx.impl_ = static_cast<void*>(&micro_context_);
  // Setup tflitecontext functions
  ctx.AllocatePersistentBuffer = &AllocatePersistentBufferImpl;
  ctx.RequestScratchBufferInArena = &RequestScratchBufferInArenaImpl;
  ctx.GetScratchBuffer = &GetScratchBufferImpl;
  ctx.GetTensor = &GetTensorImpl;
  ctx.GetEvalTensor = &GetEvalTensorImpl;
  ctx.ReportError = &MicroContextReportOpError;

  ctx.tensors_size = 31;
  for (size_t i = 0; i < 31; ++i) {
    TfLiteTensor tensor;
    init_tflite_tensor(i, &tensor);
    if (tensor.allocation_type == kTfLiteArenaRw) {
      auto data_end_ptr = (uint8_t*)tensor.data.data + tensorData[i].bytes;
      if (data_end_ptr > tensor_boundary) {
        tensor_boundary = data_end_ptr;
      }
    }
  }

  if (tensor_boundary > current_location /* end of arena size */) {
    ei_printf("ERR: tensor arena is too small, does not fit model - even without scratch buffers\n");
    return kTfLiteError;
  }

  registrations[OP_RESHAPE] = Register_RESHAPE();
  registrations[OP_CONV_2D] = Register_CONV_2D();
  registrations[OP_MAX_POOL_2D] = Register_MAX_POOL_2D();
  registrations[OP_FULLY_CONNECTED] = Register_FULLY_CONNECTED();
  registrations[OP_SOFTMAX] = Register_SOFTMAX();

  for (size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].init) {
        tflNodes[i].user_data = registrations[used_ops[i]].init(&ctx, (const char*)tflNodes[i].builtin_data, 0);
      }
    }
  }
  current_subgraph_index = 0;

  for(size_t g = 0; g < 1; ++g) {
    current_subgraph_index = g;
    for(size_t i = tflNodes_subgraph_index[g]; i < tflNodes_subgraph_index[g+1]; ++i) {
      if (registrations[used_ops[i]].prepare) {
        ResetTensors();
        TfLiteStatus status = registrations[used_ops[i]].prepare(&ctx, &tflNodes[i]);
        if (status != kTfLiteOk) {
          return status;
        }
      }
    }
  }
  current_subgraph_index = 0;

  return kTfLiteOk;
}

TfLiteStatus tflite_learn_5269_input(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(in_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_5269_output(int index, TfLiteTensor *tensor) {
  init_tflite_tensor(out_tensor_indices[index], tensor);
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_5269_invoke() {
  for (size_t i = 0; i < 15; ++i) {
    ResetTensors();

    TfLiteStatus status = registrations[used_ops[i]].invoke(&ctx, &tflNodes[i]);

#if EI_CLASSIFIER_PRINT_STATE
    ei_printf("layer %lu\n", i);
    ei_printf("    inputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].inputs->size; ix++) {
      auto d = tensorData[tflNodes[i].inputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");

    ei_printf("    outputs:\n");
    for (size_t ix = 0; ix < tflNodes[i].outputs->size; ix++) {
      auto d = tensorData[tflNodes[i].outputs->data[ix]];

      size_t data_ptr = (size_t)d.data;

      if (d.allocation_type == kTfLiteArenaRw) {
        data_ptr = (size_t)tensor_arena + data_ptr;
      }

      if (d.type == TfLiteType::kTfLiteInt8) {
        int8_t* data = (int8_t*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes; jx++) {
          ei_printf("%d ", data[jx]);
        }
      }
      else {
        float* data = (float*)data_ptr;
        ei_printf("        %lu (%zu bytes, ptr=%p, alloc_type=%d, type=%d): ", ix, d.bytes, data, (int)d.allocation_type, (int)d.type);
        for (size_t jx = 0; jx < d.bytes / 4; jx++) {
          ei_printf("%f ", data[jx]);
        }
      }
      ei_printf("\n");
    }
    ei_printf("\n");
#endif // EI_CLASSIFIER_PRINT_STATE

    if (status != kTfLiteOk) {
      return status;
    }
  }
  return kTfLiteOk;
}

TfLiteStatus tflite_learn_5269_reset( void (*free_fnc)(void* ptr) ) {
#ifdef EI_CLASSIFIER_ALLOCATION_HEAP
  free_fnc(tensor_arena);
#endif

  // scratch buffers are allocated within the arena, so just reset the counter so memory can be reused
  scratch_buffers_ix = 0;

  // overflow buffers are on the heap, so free them first
  for (size_t ix = 0; ix < overflow_buffers_ix; ix++) {
    ei_free(overflow_buffers[ix]);
  }
  overflow_buffers_ix = 0;
  return kTfLiteOk;
}
